/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "GetOrSetNonceError": () => (/* reexport */ GetOrSetNonceError),
  "default": () => (/* reexport */ torus),
  "kCombinations": () => (/* reexport */ kCombinations),
  "keccak256": () => (/* reexport */ keccak256),
  "keyAssign": () => (/* reexport */ keyAssign),
  "keyLookup": () => (/* reexport */ keyLookup),
  "thresholdSame": () => (/* reexport */ thresholdSame),
  "waitKeyLookup": () => (/* reexport */ waitKeyLookup)
});

;// CONCATENATED MODULE: external "@babel/runtime/helpers/typeof"
const typeof_namespaceObject = require("@babel/runtime/helpers/typeof");
var typeof_default = /*#__PURE__*/__webpack_require__.n(typeof_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/asyncToGenerator"
const asyncToGenerator_namespaceObject = require("@babel/runtime/helpers/asyncToGenerator");
var asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/classCallCheck"
const classCallCheck_namespaceObject = require("@babel/runtime/helpers/classCallCheck");
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/createClass"
const createClass_namespaceObject = require("@babel/runtime/helpers/createClass");
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/defineProperty"
const defineProperty_namespaceObject = require("@babel/runtime/helpers/defineProperty");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/regenerator"
const regenerator_namespaceObject = require("@babel/runtime/regenerator");
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator_namespaceObject);
;// CONCATENATED MODULE: external "@toruslabs/eccrypto"
const eccrypto_namespaceObject = require("@toruslabs/eccrypto");
;// CONCATENATED MODULE: external "@toruslabs/http-helpers"
const http_helpers_namespaceObject = require("@toruslabs/http-helpers");
;// CONCATENATED MODULE: external "bn.js"
const external_bn_js_namespaceObject = require("bn.js");
var external_bn_js_default = /*#__PURE__*/__webpack_require__.n(external_bn_js_namespaceObject);
;// CONCATENATED MODULE: external "elliptic"
const external_elliptic_namespaceObject = require("elliptic");
;// CONCATENATED MODULE: external "json-stable-stringify"
const external_json_stable_stringify_namespaceObject = require("json-stable-stringify");
var external_json_stable_stringify_default = /*#__PURE__*/__webpack_require__.n(external_json_stable_stringify_namespaceObject);
;// CONCATENATED MODULE: external "web3-utils"
const external_web3_utils_namespaceObject = require("web3-utils");
;// CONCATENATED MODULE: external "loglevel"
const external_loglevel_namespaceObject = require("loglevel");
var external_loglevel_default = /*#__PURE__*/__webpack_require__.n(external_loglevel_namespaceObject);
;// CONCATENATED MODULE: ./src/loglevel.ts

var log = external_loglevel_default().getLogger("torus.js");
log.disableAll();
/* harmony default export */ const loglevel = (log);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/assertThisInitialized"
const assertThisInitialized_namespaceObject = require("@babel/runtime/helpers/assertThisInitialized");
var assertThisInitialized_default = /*#__PURE__*/__webpack_require__.n(assertThisInitialized_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/inherits"
const inherits_namespaceObject = require("@babel/runtime/helpers/inherits");
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/possibleConstructorReturn"
const possibleConstructorReturn_namespaceObject = require("@babel/runtime/helpers/possibleConstructorReturn");
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/getPrototypeOf"
const getPrototypeOf_namespaceObject = require("@babel/runtime/helpers/getPrototypeOf");
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf_namespaceObject);
;// CONCATENATED MODULE: external "@babel/runtime/helpers/wrapNativeSuper"
const wrapNativeSuper_namespaceObject = require("@babel/runtime/helpers/wrapNativeSuper");
var wrapNativeSuper_default = /*#__PURE__*/__webpack_require__.n(wrapNativeSuper_namespaceObject);
;// CONCATENATED MODULE: ./src/some.ts









function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function capitalizeFirstLetter(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

var SomeError = /*#__PURE__*/function (_Error) {
  inherits_default()(SomeError, _Error);

  var _super = _createSuper(SomeError);

  function SomeError(_ref) {
    var _this;

    var errors = _ref.errors,
        responses = _ref.responses,
        predicate = _ref.predicate;

    classCallCheck_default()(this, SomeError);

    _this = _super.call(this, "Unable to resolve enough promises.");

    defineProperty_default()(assertThisInitialized_default()(_this), "errors", void 0);

    defineProperty_default()(assertThisInitialized_default()(_this), "responses", void 0);

    defineProperty_default()(assertThisInitialized_default()(_this), "predicate", void 0);

    _this.errors = errors;
    _this.responses = responses;
    _this.predicate = predicate;
    return _this;
  }

  return createClass_default()(SomeError);
}( /*#__PURE__*/wrapNativeSuper_default()(Error));
var Some = function Some(promises, predicate) {
  return new Promise(function (resolve, reject) {
    var finishedCount = 0;
    var sharedState = {
      resolved: false
    };
    var errorArr = new Array(promises.length).fill(undefined);
    var resultArr = new Array(promises.length).fill(undefined);
    var predicateError;
    return promises.forEach(function (x, index) {
      return x.then(function (resp) {
        resultArr[index] = resp;
        return undefined;
      }).catch(function (error) {
        errorArr[index] = error;
      }) // eslint-disable-next-line promise/no-return-in-finally
      .finally(function () {
        if (sharedState.resolved) return;
        return predicate(resultArr.slice(0), sharedState).then(function (data) {
          sharedState.resolved = true;
          resolve(data);
          return undefined;
        }).catch(function (error) {
          // log only the last predicate error
          predicateError = error;
        }).finally(function () {
          finishedCount += 1;

          if (finishedCount === promises.length) {
            var errors = Object.values(resultArr.reduce(function (acc, z) {
              if (z) {
                var _error$data;

                var _ref2 = z,
                    id = _ref2.id,
                    error = _ref2.error;

                if ((error === null || error === void 0 ? void 0 : (_error$data = error.data) === null || _error$data === void 0 ? void 0 : _error$data.length) > 0) {
                  if (error.data.startsWith("Error occurred while verifying params")) acc[id] = capitalizeFirstLetter(error.data);else acc[id] = error.data;
                }
              }

              return acc;
            }, {}));

            if (errors.length > 0) {
              // Format-able errors
              var msg = errors.length > 1 ? "\n".concat(errors.map(function (it) {
                return "\u2022 ".concat(it);
              }).join("\n")) : errors[0];
              reject(new Error(msg));
            } else {
              var _predicateError;

              reject(new SomeError({
                errors: errorArr,
                responses: resultArr,
                predicate: ((_predicateError = predicateError) === null || _predicateError === void 0 ? void 0 : _predicateError.message) || predicateError
              }));
            }
          }
        });
      });
    });
  });
};
;// CONCATENATED MODULE: external "@babel/runtime/helpers/toConsumableArray"
const toConsumableArray_namespaceObject = require("@babel/runtime/helpers/toConsumableArray");
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray_namespaceObject);
;// CONCATENATED MODULE: external "keccak"
const external_keccak_namespaceObject = require("keccak");
var external_keccak_default = /*#__PURE__*/__webpack_require__.n(external_keccak_namespaceObject);
;// CONCATENATED MODULE: ./src/utils.ts










function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { defineProperty_default()(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }



function utils_createSuper(Derived) { var hasNativeReflectConstruct = utils_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function utils_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






var GetOrSetNonceError = /*#__PURE__*/function (_Error) {
  inherits_default()(GetOrSetNonceError, _Error);

  var _super = utils_createSuper(GetOrSetNonceError);

  function GetOrSetNonceError() {
    classCallCheck_default()(this, GetOrSetNonceError);

    return _super.apply(this, arguments);
  }

  return createClass_default()(GetOrSetNonceError);
}( /*#__PURE__*/wrapNativeSuper_default()(Error));
var kCombinations = function kCombinations(s, k) {
  var set = s;

  if (typeof set === "number") {
    set = Array.from({
      length: set
    }, function (_, i) {
      return i;
    });
  }

  if (k > set.length || k <= 0) {
    return [];
  }

  if (k === set.length) {
    return [set];
  }

  if (k === 1) {
    return set.reduce(function (acc, cur) {
      return [].concat(toConsumableArray_default()(acc), [[cur]]);
    }, []);
  }

  var combs = [];
  var tailCombs = [];

  for (var i = 0; i <= set.length - k + 1; i += 1) {
    tailCombs = kCombinations(set.slice(i + 1), k - 1);

    for (var j = 0; j < tailCombs.length; j += 1) {
      combs.push([set[i]].concat(toConsumableArray_default()(tailCombs[j])));
    }
  }

  return combs;
};
var thresholdSame = function thresholdSame(arr, t) {
  var hashMap = {};

  for (var i = 0; i < arr.length; i += 1) {
    var str = external_json_stable_stringify_default()(arr[i]);
    hashMap[str] = hashMap[str] ? hashMap[str] + 1 : 1;

    if (hashMap[str] === t) {
      return arr[i];
    }
  }

  return undefined;
};
var keyLookup = /*#__PURE__*/function () {
  var _ref = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee(endpoints, verifier, verifierId) {
    var lookupPromises;
    return regenerator_default().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            lookupPromises = endpoints.map(function (x) {
              return (0,http_helpers_namespaceObject.post)(x, (0,http_helpers_namespaceObject.generateJsonRPCObject)("VerifierLookupRequest", {
                verifier: verifier,
                verifier_id: verifierId.toString()
              })).catch(function (err) {
                return loglevel.error("lookup request failed", err);
              });
            });
            return _context.abrupt("return", Some(lookupPromises, function (lookupResults) {
              var lookupShares = lookupResults.filter(function (x1) {
                return x1;
              });
              var errorResult = thresholdSame(lookupShares.map(function (x2) {
                return x2 && x2.error;
              }), ~~(endpoints.length / 2) + 1);
              var keyResult = thresholdSame(lookupShares.map(function (x3) {
                return x3 && x3.result;
              }), ~~(endpoints.length / 2) + 1);

              if (keyResult || errorResult) {
                return Promise.resolve({
                  keyResult: keyResult,
                  errorResult: errorResult
                });
              }

              return Promise.reject(new Error("invalid results ".concat(JSON.stringify(lookupResults))));
            }));

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function keyLookup(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();
var waitKeyLookup = function waitKeyLookup(endpoints, verifier, verifierId, timeout) {
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      keyLookup(endpoints, verifier, verifierId).then(resolve).catch(reject);
    }, timeout);
  });
};
var keyAssign = /*#__PURE__*/function () {
  var _ref3 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee2(_ref2) {
    var endpoints, torusNodePubs, lastPoint, firstPoint, verifier, verifierId, signerHost, network, nodeNum, initialPoint, data, signedData, acceptedErrorMsgs;
    return regenerator_default().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            endpoints = _ref2.endpoints, torusNodePubs = _ref2.torusNodePubs, lastPoint = _ref2.lastPoint, firstPoint = _ref2.firstPoint, verifier = _ref2.verifier, verifierId = _ref2.verifierId, signerHost = _ref2.signerHost, network = _ref2.network;

            if (lastPoint === undefined) {
              nodeNum = Math.floor(Math.random() * endpoints.length);
              initialPoint = nodeNum;
            } else {
              nodeNum = lastPoint % endpoints.length;
            }

            if (!(nodeNum === firstPoint)) {
              _context2.next = 4;
              break;
            }

            throw new Error("Looped through all");

          case 4:
            if (firstPoint !== undefined) initialPoint = firstPoint;
            data = (0,http_helpers_namespaceObject.generateJsonRPCObject)("KeyAssign", {
              verifier: verifier,
              verifier_id: verifierId.toString()
            });
            _context2.prev = 6;
            _context2.next = 9;
            return (0,http_helpers_namespaceObject.post)(signerHost, data, {
              headers: {
                pubKeyX: torusNodePubs[nodeNum].X,
                pubKeyY: torusNodePubs[nodeNum].Y,
                network: network
              }
            }, {
              useAPIKey: true
            });

          case 9:
            signedData = _context2.sent;
            _context2.next = 12;
            return (0,http_helpers_namespaceObject.post)(endpoints[nodeNum], _objectSpread(_objectSpread({}, data), signedData), {
              headers: {
                "Content-Type": "application/json; charset=utf-8"
              }
            });

          case 12:
            return _context2.abrupt("return", _context2.sent);

          case 15:
            _context2.prev = 15;
            _context2.t0 = _context2["catch"](6);
            loglevel.error(_context2.t0);
            acceptedErrorMsgs = [// Slow node
            "Timed out", // Happens when the node is not reachable (dns issue etc)
            "TypeError: Failed to fetch", // All except iOS and Firefox
            "TypeError: cancelled", // iOS
            "TypeError: NetworkError when attempting to fetch resource." // Firefox
            ];

            if (!acceptedErrorMsgs.includes(_context2.t0.message)) {
              _context2.next = 21;
              break;
            }

            return _context2.abrupt("return", keyAssign({
              endpoints: endpoints,
              torusNodePubs: torusNodePubs,
              lastPoint: nodeNum + 1,
              firstPoint: initialPoint,
              verifier: verifier,
              verifierId: verifierId,
              signerHost: signerHost,
              network: network
            }));

          case 21:
            throw new Error("Sorry, the Torus Network that powers Web3Auth is currently very busy.\n    We will generate your key in time. Pls try again later. \n\n    ".concat(_context2.t0.message || ""));

          case 22:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[6, 15]]);
  }));

  return function keyAssign(_x4) {
    return _ref3.apply(this, arguments);
  };
}();
function keccak256(a) {
  var hash = external_keccak_default()("keccak256").update(a).digest().toString("hex");
  return "0x".concat(hash);
}
;// CONCATENATED MODULE: ./src/torus.ts






function torus_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function torus_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? torus_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_default()(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : torus_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }










 // Implement threshold logic wrappers around public APIs
// of Torus nodes to handle malicious node responses

var Torus = /*#__PURE__*/function () {
  function Torus() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$enableOneKey = _ref.enableOneKey,
        enableOneKey = _ref$enableOneKey === void 0 ? false : _ref$enableOneKey,
        _ref$metadataHost = _ref.metadataHost,
        metadataHost = _ref$metadataHost === void 0 ? "https://metadata.tor.us" : _ref$metadataHost,
        _ref$allowHost = _ref.allowHost,
        allowHost = _ref$allowHost === void 0 ? "https://signer.tor.us/api/allow" : _ref$allowHost,
        _ref$signerHost = _ref.signerHost,
        signerHost = _ref$signerHost === void 0 ? "https://signer.tor.us/api/sign" : _ref$signerHost,
        _ref$serverTimeOffset = _ref.serverTimeOffset,
        serverTimeOffset = _ref$serverTimeOffset === void 0 ? 0 : _ref$serverTimeOffset,
        _ref$network = _ref.network,
        network = _ref$network === void 0 ? "mainnet" : _ref$network;

    classCallCheck_default()(this, Torus);

    defineProperty_default()(this, "metadataHost", void 0);

    defineProperty_default()(this, "allowHost", void 0);

    defineProperty_default()(this, "serverTimeOffset", void 0);

    defineProperty_default()(this, "enableOneKey", void 0);

    defineProperty_default()(this, "signerHost", void 0);

    defineProperty_default()(this, "network", void 0);

    defineProperty_default()(this, "ec", void 0);

    this.ec = new external_elliptic_namespaceObject.ec("secp256k1");
    this.metadataHost = metadataHost;
    this.allowHost = allowHost;
    this.enableOneKey = enableOneKey;
    this.serverTimeOffset = serverTimeOffset || 0; // ms

    this.signerHost = signerHost;
    this.network = network;
  }

  createClass_default()(Torus, [{
    key: "getUserTypeAndAddress",
    value:
    /**
     * Note: use this function only for openlogin tkey account lookups.
     */
    function () {
      var _getUserTypeAndAddress = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee(endpoints, torusNodePubs, _ref2) {
        var verifier,
            verifierId,
            doesKeyAssign,
            _ref3,
            keyResult,
            errorResult,
            isNewKey,
            finalKeyResult,
            assignResult,
            _finalKeyResult$keys$,
            X,
            Y,
            nonceResult,
            nonce,
            modifiedPubKey,
            finalX,
            finalY,
            address,
            _args = arguments;

        return regenerator_default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                verifier = _ref2.verifier, verifierId = _ref2.verifierId;
                doesKeyAssign = _args.length > 3 && _args[3] !== undefined ? _args[3] : false;
                _context.next = 4;
                return keyLookup(endpoints, verifier, verifierId);

              case 4:
                _context.t0 = _context.sent;

                if (_context.t0) {
                  _context.next = 7;
                  break;
                }

                _context.t0 = {};

              case 7:
                _ref3 = _context.t0;
                keyResult = _ref3.keyResult;
                errorResult = _ref3.errorResult;
                isNewKey = false;

                if (!(errorResult && JSON.stringify(errorResult).includes("Verifier + VerifierID has not yet been assigned"))) {
                  _context.next = 23;
                  break;
                }

                if (doesKeyAssign) {
                  _context.next = 14;
                  break;
                }

                throw new Error("Verifier + VerifierID has not yet been assigned");

              case 14:
                _context.next = 16;
                return keyAssign({
                  endpoints: endpoints,
                  torusNodePubs: torusNodePubs,
                  lastPoint: undefined,
                  firstPoint: undefined,
                  verifier: verifier,
                  verifierId: verifierId,
                  signerHost: this.signerHost,
                  network: this.network
                });

              case 16:
                _context.next = 18;
                return waitKeyLookup(endpoints, verifier, verifierId, 1000);

              case 18:
                assignResult = _context.sent;
                finalKeyResult = assignResult === null || assignResult === void 0 ? void 0 : assignResult.keyResult;
                isNewKey = true;
                _context.next = 28;
                break;

              case 23:
                if (!keyResult) {
                  _context.next = 27;
                  break;
                }

                finalKeyResult = keyResult;
                _context.next = 28;
                break;

              case 27:
                throw new Error("node results do not match at first lookup ".concat(JSON.stringify(keyResult || {}), ", ").concat(JSON.stringify(errorResult || {})));

              case 28:
                if (!finalKeyResult) {
                  _context.next = 58;
                  break;
                }

                _finalKeyResult$keys$ = finalKeyResult.keys[0], X = _finalKeyResult$keys$.pub_key_X, Y = _finalKeyResult$keys$.pub_key_Y;
                _context.prev = 30;
                _context.next = 33;
                return this.getOrSetNonce(X, Y, undefined, !isNewKey);

              case 33:
                nonceResult = _context.sent;
                nonce = new (external_bn_js_default())(nonceResult.nonce || "0", 16);
                _context.next = 40;
                break;

              case 37:
                _context.prev = 37;
                _context.t1 = _context["catch"](30);
                throw new GetOrSetNonceError();

              case 40:
                if (!(nonceResult.typeOfUser === "v1")) {
                  _context.next = 44;
                  break;
                }

                modifiedPubKey = this.ec.keyFromPublic({
                  x: X,
                  y: Y
                }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());
                _context.next = 49;
                break;

              case 44:
                if (!(nonceResult.typeOfUser === "v2")) {
                  _context.next = 48;
                  break;
                }

                modifiedPubKey = this.ec.keyFromPublic({
                  x: X,
                  y: Y
                }).getPublic().add(this.ec.keyFromPublic({
                  x: nonceResult.pubNonce.x,
                  y: nonceResult.pubNonce.y
                }).getPublic());
                _context.next = 49;
                break;

              case 48:
                throw new Error("getOrSetNonce should always return typeOfUser.");

              case 49:
                finalX = modifiedPubKey.getX().toString(16);
                finalY = modifiedPubKey.getY().toString(16);
                address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY());

                if (!(nonceResult.typeOfUser === "v1")) {
                  _context.next = 56;
                  break;
                }

                return _context.abrupt("return", {
                  typeOfUser: nonceResult.typeOfUser,
                  nonce: nonce,
                  X: finalX,
                  Y: finalY,
                  address: address
                });

              case 56:
                if (!(nonceResult.typeOfUser === "v2")) {
                  _context.next = 58;
                  break;
                }

                return _context.abrupt("return", {
                  typeOfUser: nonceResult.typeOfUser,
                  nonce: nonce,
                  pubNonce: nonceResult.pubNonce,
                  upgraded: nonceResult.upgraded,
                  X: finalX,
                  Y: finalY,
                  address: address
                });

              case 58:
                throw new Error("node results do not match at final lookup ".concat(JSON.stringify(keyResult || {}), ", ").concat(JSON.stringify(errorResult || {})));

              case 59:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[30, 37]]);
      }));

      function getUserTypeAndAddress(_x, _x2, _x3) {
        return _getUserTypeAndAddress.apply(this, arguments);
      }

      return getUserTypeAndAddress;
    }()
  }, {
    key: "setCustomKey",
    value: function () {
      var _setCustomKey = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee2(_ref4) {
        var privKeyHex, metadataNonce, torusKeyHex, customKeyHex, torusKey, privKey, customKey, newMetadataNonce, data;
        return regenerator_default().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                privKeyHex = _ref4.privKeyHex, metadataNonce = _ref4.metadataNonce, torusKeyHex = _ref4.torusKeyHex, customKeyHex = _ref4.customKeyHex;

                if (torusKeyHex) {
                  torusKey = new (external_bn_js_default())(torusKeyHex, 16);
                } else {
                  privKey = new (external_bn_js_default())(privKeyHex, 16);
                  torusKey = privKey.sub(metadataNonce).umod(this.ec.curve.n);
                }

                customKey = new (external_bn_js_default())(customKeyHex, 16);
                newMetadataNonce = customKey.sub(torusKey).umod(this.ec.curve.n);
                data = this.generateMetadataParams(newMetadataNonce.toString(16), torusKey);
                _context2.next = 7;
                return this.setMetadata(data);

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function setCustomKey(_x4) {
        return _setCustomKey.apply(this, arguments);
      }

      return setCustomKey;
    }()
  }, {
    key: "retrieveShares",
    value: function () {
      var _retrieveShares = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee5(endpoints, indexes, verifier, verifierParams, idToken) {
        var _this = this;

        var extraParams,
            promiseArr,
            tmpKey,
            pubKey,
            pubKeyX,
            pubKeyY,
            tokenCommitment,
            i,
            p,
            _args5 = arguments;
        return regenerator_default().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                extraParams = _args5.length > 5 && _args5[5] !== undefined ? _args5[5] : {};
                promiseArr = [];
                _context5.next = 4;
                return (0,http_helpers_namespaceObject.get)(this.allowHost, {
                  headers: {
                    verifier: verifier,
                    verifier_id: verifierParams.verifier_id,
                    network: this.network
                  }
                }, {
                  useAPIKey: true
                });

              case 4:
                /*
                  CommitmentRequestParams struct {
                    MessagePrefix      string `json:"messageprefix"`
                    TokenCommitment    string `json:"tokencommitment"`
                    TempPubX           string `json:"temppubx"`
                    TempPubY           string `json:"temppuby"`
                    VerifierIdentifier string `json:"verifieridentifier"`
                  } 
                  */
                // generate temporary private and public key that is used to secure receive shares
                tmpKey = (0,eccrypto_namespaceObject.generatePrivate)();
                pubKey = (0,eccrypto_namespaceObject.getPublic)(tmpKey).toString("hex");
                pubKeyX = pubKey.slice(2, 66);
                pubKeyY = pubKey.slice(66);
                tokenCommitment = keccak256(idToken); // make commitment requests to endpoints

                for (i = 0; i < endpoints.length; i += 1) {
                  p = (0,http_helpers_namespaceObject.post)(endpoints[i], (0,http_helpers_namespaceObject.generateJsonRPCObject)("CommitmentRequest", {
                    messageprefix: "mug00",
                    tokencommitment: tokenCommitment.slice(2),
                    temppubx: pubKeyX,
                    temppuby: pubKeyY,
                    verifieridentifier: verifier
                  })).catch(function (err) {
                    loglevel.error("commitment", err);
                  });
                  promiseArr.push(p);
                }
                /*
                  ShareRequestParams struct {
                    Item []bijson.RawMessage `json:"item"`
                  }
                  ShareRequestItem struct {
                    IDToken            string          `json:"idtoken"`
                    NodeSignatures     []NodeSignature `json:"nodesignatures"`
                    VerifierIdentifier string          `json:"verifieridentifier"`
                  }
                  NodeSignature struct {
                    Signature   string
                    Data        string
                    NodePubKeyX string
                    NodePubKeyY string
                  }
                  CommitmentRequestResult struct {
                    Signature string `json:"signature"`
                    Data      string `json:"data"`
                    NodePubX  string `json:"nodepubx"`
                    NodePubY  string `json:"nodepuby"`
                  }
                  */
                // send share request once k + t number of commitment requests have completed


                return _context5.abrupt("return", Some(promiseArr, function (resultArr) {
                  var completedRequests = resultArr.filter(function (x) {
                    if (!x || typeof_default()(x) !== "object") {
                      return false;
                    }

                    if (x.error) {
                      return false;
                    }

                    return true;
                  });

                  if (completedRequests.length >= ~~(endpoints.length / 4) * 3 + 1) {
                    return Promise.resolve(resultArr);
                  }

                  return Promise.reject(new Error("invalid ".concat(JSON.stringify(resultArr))));
                }).then(function (responses) {
                  var promiseArrRequest = [];
                  var nodeSigs = [];

                  for (var _i = 0; _i < responses.length; _i += 1) {
                    if (responses[_i]) nodeSigs.push(responses[_i].result);
                  }

                  for (var _i2 = 0; _i2 < endpoints.length; _i2 += 1) {
                    // eslint-disable-next-line promise/no-nesting
                    var _p = (0,http_helpers_namespaceObject.post)(endpoints[_i2], (0,http_helpers_namespaceObject.generateJsonRPCObject)("ShareRequest", {
                      encrypted: "yes",
                      item: [torus_objectSpread(torus_objectSpread({}, verifierParams), {}, {
                        idtoken: idToken,
                        nodesignatures: nodeSigs,
                        verifieridentifier: verifier
                      }, extraParams)]
                    })).catch(function (err) {
                      return loglevel.error("share req", err);
                    });

                    promiseArrRequest.push(_p);
                  }

                  return Some(promiseArrRequest, /*#__PURE__*/function () {
                    var _ref5 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee3(shareResponses, sharedState) {
                      var completedRequests, thresholdPublicKey, sharePromises, nodeIndexes, _i3, _currentShareResponse, _currentShareResponse2, currentShareResponse, firstKey, metadata, sharesResolved, decryptedShares, allCombis, privateKey, _loop, j, _ret;

                      return regenerator_default().wrap(function _callee3$(_context3) {
                        while (1) {
                          switch (_context3.prev = _context3.next) {
                            case 0:
                              /*
                                  ShareRequestResult struct {
                                    Keys []KeyAssignment
                                  }
                                          / KeyAssignmentPublic -
                                  type KeyAssignmentPublic struct {
                                    Index     big.Int
                                    PublicKey common.Point
                                    Threshold int
                                    Verifiers map[string][]string // Verifier => VerifierID
                                  }
                                   // KeyAssignment -
                                  type KeyAssignment struct {
                                    KeyAssignmentPublic
                                    Share big.Int // Or Si
                                  }
                                */
                              // check if threshold number of nodes have returned the same user public key
                              completedRequests = shareResponses.filter(function (x) {
                                return x;
                              });
                              thresholdPublicKey = thresholdSame(shareResponses.map(function (x) {
                                return x && x.result && x.result.keys[0].PublicKey;
                              }), ~~(endpoints.length / 2) + 1); // optimistically run lagrange interpolation once threshold number of shares have been received
                              // this is matched against the user public key to ensure that shares are consistent

                              if (!(completedRequests.length >= ~~(endpoints.length / 2) + 1 && thresholdPublicKey)) {
                                _context3.next = 28;
                                break;
                              }

                              sharePromises = [];
                              nodeIndexes = [];

                              for (_i3 = 0; _i3 < shareResponses.length; _i3 += 1) {
                                currentShareResponse = shareResponses[_i3];

                                if ((currentShareResponse === null || currentShareResponse === void 0 ? void 0 : (_currentShareResponse = currentShareResponse.result) === null || _currentShareResponse === void 0 ? void 0 : (_currentShareResponse2 = _currentShareResponse.keys) === null || _currentShareResponse2 === void 0 ? void 0 : _currentShareResponse2.length) > 0) {
                                  currentShareResponse.result.keys.sort(function (a, b) {
                                    return new (external_bn_js_default())(a.Index, 16).cmp(new (external_bn_js_default())(b.Index, 16));
                                  });
                                  firstKey = currentShareResponse.result.keys[0];

                                  if (firstKey.Metadata) {
                                    metadata = {
                                      ephemPublicKey: Buffer.from(firstKey.Metadata.ephemPublicKey, "hex"),
                                      iv: Buffer.from(firstKey.Metadata.iv, "hex"),
                                      mac: Buffer.from(firstKey.Metadata.mac, "hex") // mode: Buffer.from(firstKey.Metadata.mode, "hex"),

                                    };
                                    sharePromises.push( // eslint-disable-next-line promise/no-nesting
                                    (0,eccrypto_namespaceObject.decrypt)(tmpKey, torus_objectSpread(torus_objectSpread({}, metadata), {}, {
                                      ciphertext: Buffer.from(Buffer.from(firstKey.Share, "base64").toString("binary").padStart(64, "0"), "hex")
                                    })).catch(function (err) {
                                      return loglevel.debug("share decryption", err);
                                    }));
                                  } else {
                                    sharePromises.push(Promise.resolve(Buffer.from(firstKey.Share.padStart(64, "0"), "hex")));
                                  }
                                } else {
                                  sharePromises.push(Promise.resolve(undefined));
                                }

                                nodeIndexes.push(new (external_bn_js_default())(indexes[_i3], 16));
                              }

                              _context3.next = 8;
                              return Promise.all(sharePromises);

                            case 8:
                              sharesResolved = _context3.sent;

                              if (!sharedState.resolved) {
                                _context3.next = 11;
                                break;
                              }

                              return _context3.abrupt("return", undefined);

                            case 11:
                              decryptedShares = sharesResolved.reduce(function (acc, curr, index) {
                                if (curr) acc.push({
                                  index: nodeIndexes[index],
                                  value: new (external_bn_js_default())(curr)
                                });
                                return acc;
                              }, []); // run lagrange interpolation on all subsets, faster in the optimistic scenario than berlekamp-welch due to early exit

                              // run lagrange interpolation on all subsets, faster in the optimistic scenario than berlekamp-welch due to early exit
                              allCombis = kCombinations(decryptedShares.length, ~~(endpoints.length / 2) + 1);
                              privateKey = null;

                              _loop = function _loop(j) {
                                var currentCombi = allCombis[j];
                                var currentCombiShares = decryptedShares.filter(function (v, index) {
                                  return currentCombi.includes(index);
                                });
                                var shares = currentCombiShares.map(function (x) {
                                  return x.value;
                                });
                                var indices = currentCombiShares.map(function (x) {
                                  return x.index;
                                });

                                var derivedPrivateKey = _this.lagrangeInterpolation(shares, indices);

                                if (!derivedPrivateKey) return "continue";
                                var decryptedPubKey = (0,eccrypto_namespaceObject.getPublic)(Buffer.from(derivedPrivateKey.toString(16, 64), "hex")).toString("hex");
                                var decryptedPubKeyX = decryptedPubKey.slice(2, 66);
                                var decryptedPubKeyY = decryptedPubKey.slice(66);

                                if (new (external_bn_js_default())(decryptedPubKeyX, 16).cmp(new (external_bn_js_default())(thresholdPublicKey.X, 16)) === 0 && new (external_bn_js_default())(decryptedPubKeyY, 16).cmp(new (external_bn_js_default())(thresholdPublicKey.Y, 16)) === 0) {
                                  privateKey = derivedPrivateKey;
                                  return "break";
                                }
                              };

                              j = 0;

                            case 16:
                              if (!(j < allCombis.length)) {
                                _context3.next = 25;
                                break;
                              }

                              _ret = _loop(j);

                              if (!(_ret === "continue")) {
                                _context3.next = 20;
                                break;
                              }

                              return _context3.abrupt("continue", 22);

                            case 20:
                              if (!(_ret === "break")) {
                                _context3.next = 22;
                                break;
                              }

                              return _context3.abrupt("break", 25);

                            case 22:
                              j += 1;
                              _context3.next = 16;
                              break;

                            case 25:
                              if (!(privateKey === undefined || privateKey === null)) {
                                _context3.next = 27;
                                break;
                              }

                              throw new Error("could not derive private key");

                            case 27:
                              return _context3.abrupt("return", privateKey);

                            case 28:
                              throw new Error("invalid");

                            case 29:
                            case "end":
                              return _context3.stop();
                          }
                        }
                      }, _callee3);
                    }));

                    return function (_x10, _x11) {
                      return _ref5.apply(this, arguments);
                    };
                  }());
                }).then( /*#__PURE__*/function () {
                  var _ref6 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee4(returnedKey) {
                    var privateKey, decryptedPubKey, decryptedPubKeyX, decryptedPubKeyY, metadataNonce, _yield$_this$getNonce, nonce, ethAddress;

                    return regenerator_default().wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            privateKey = returnedKey;

                            if (privateKey) {
                              _context4.next = 3;
                              break;
                            }

                            throw new Error("Invalid private key returned");

                          case 3:
                            decryptedPubKey = (0,eccrypto_namespaceObject.getPublic)(Buffer.from(privateKey.toString(16, 64), "hex")).toString("hex");
                            decryptedPubKeyX = decryptedPubKey.slice(2, 66);
                            decryptedPubKeyY = decryptedPubKey.slice(66);

                            if (!_this.enableOneKey) {
                              _context4.next = 14;
                              break;
                            }

                            _context4.next = 9;
                            return _this.getNonce(decryptedPubKeyX, decryptedPubKeyY, privateKey);

                          case 9:
                            _yield$_this$getNonce = _context4.sent;
                            nonce = _yield$_this$getNonce.nonce;
                            metadataNonce = new (external_bn_js_default())(nonce || "0", 16);
                            _context4.next = 17;
                            break;

                          case 14:
                            _context4.next = 16;
                            return _this.getMetadata({
                              pub_key_X: decryptedPubKeyX,
                              pub_key_Y: decryptedPubKeyY
                            });

                          case 16:
                            metadataNonce = _context4.sent;

                          case 17:
                            loglevel.debug("> torus.js/retrieveShares", {
                              privKey: privateKey.toString(16),
                              metadataNonce: metadataNonce.toString(16)
                            });
                            privateKey = privateKey.add(metadataNonce).umod(_this.ec.curve.n);
                            ethAddress = _this.generateAddressFromPrivKey(privateKey);
                            loglevel.debug("> torus.js/retrieveShares", {
                              ethAddress: ethAddress,
                              privKey: privateKey.toString(16)
                            }); // return reconstructed private key and ethereum address

                            return _context4.abrupt("return", {
                              ethAddress: ethAddress,
                              privKey: privateKey.toString("hex", 64),
                              metadataNonce: metadataNonce
                            });

                          case 22:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function (_x12) {
                    return _ref6.apply(this, arguments);
                  };
                }()));

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function retrieveShares(_x5, _x6, _x7, _x8, _x9) {
        return _retrieveShares.apply(this, arguments);
      }

      return retrieveShares;
    }()
  }, {
    key: "getMetadata",
    value: function () {
      var _getMetadata = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee6(data) {
        var options,
            metadataResponse,
            _args6 = arguments;
        return regenerator_default().wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                options = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};
                _context6.prev = 1;
                _context6.next = 4;
                return (0,http_helpers_namespaceObject.post)("".concat(this.metadataHost, "/get"), data, options, {
                  useAPIKey: true
                });

              case 4:
                metadataResponse = _context6.sent;

                if (!(!metadataResponse || !metadataResponse.message)) {
                  _context6.next = 7;
                  break;
                }

                return _context6.abrupt("return", new (external_bn_js_default())(0));

              case 7:
                return _context6.abrupt("return", new (external_bn_js_default())(metadataResponse.message, 16));

              case 10:
                _context6.prev = 10;
                _context6.t0 = _context6["catch"](1);
                loglevel.error("get metadata error", _context6.t0);
                return _context6.abrupt("return", new (external_bn_js_default())(0));

              case 14:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[1, 10]]);
      }));

      function getMetadata(_x13) {
        return _getMetadata.apply(this, arguments);
      }

      return getMetadata;
    }()
  }, {
    key: "generateMetadataParams",
    value: function generateMetadataParams(message, privateKey) {
      var key = this.ec.keyFromPrivate(privateKey.toString("hex", 64));
      var setData = {
        data: message,
        timestamp: new (external_bn_js_default())(~~(this.serverTimeOffset + Date.now() / 1000)).toString(16)
      };
      var sig = key.sign(keccak256(external_json_stable_stringify_default()(setData)).slice(2));
      return {
        pub_key_X: key.getPublic().getX().toString("hex"),
        pub_key_Y: key.getPublic().getY().toString("hex"),
        set_data: setData,
        signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + new (external_bn_js_default())("").toString(16, 2), "hex").toString("base64")
      };
    }
  }, {
    key: "setMetadata",
    value: function () {
      var _setMetadata = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee7(data) {
        var options,
            metadataResponse,
            _args7 = arguments;
        return regenerator_default().wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                options = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};
                _context7.prev = 1;
                _context7.next = 4;
                return (0,http_helpers_namespaceObject.post)("".concat(this.metadataHost, "/set"), data, options, {
                  useAPIKey: true
                });

              case 4:
                metadataResponse = _context7.sent;
                return _context7.abrupt("return", metadataResponse.message);

              case 8:
                _context7.prev = 8;
                _context7.t0 = _context7["catch"](1);
                loglevel.error("set metadata error", _context7.t0);
                return _context7.abrupt("return", "");

              case 12:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[1, 8]]);
      }));

      function setMetadata(_x14) {
        return _setMetadata.apply(this, arguments);
      }

      return setMetadata;
    }()
  }, {
    key: "lagrangeInterpolation",
    value: function lagrangeInterpolation(shares, nodeIndex) {
      if (shares.length !== nodeIndex.length) {
        return null;
      }

      var secret = new (external_bn_js_default())(0);

      for (var i = 0; i < shares.length; i += 1) {
        var upper = new (external_bn_js_default())(1);
        var lower = new (external_bn_js_default())(1);

        for (var j = 0; j < shares.length; j += 1) {
          if (i !== j) {
            upper = upper.mul(nodeIndex[j].neg());
            upper = upper.umod(this.ec.curve.n);
            var temp = nodeIndex[i].sub(nodeIndex[j]);
            temp = temp.umod(this.ec.curve.n);
            lower = lower.mul(temp).umod(this.ec.curve.n);
          }
        }

        var delta = upper.mul(lower.invm(this.ec.curve.n)).umod(this.ec.curve.n);
        delta = delta.mul(shares[i]).umod(this.ec.curve.n);
        secret = secret.add(delta);
      }

      return secret.umod(this.ec.curve.n);
    }
  }, {
    key: "generateAddressFromPrivKey",
    value: function generateAddressFromPrivKey(privateKey) {
      var key = this.ec.keyFromPrivate(privateKey.toString("hex", 64), "hex");
      var publicKey = key.getPublic().encode("hex", false).slice(2);
      loglevel.info(publicKey, "public key");
      var ethAddressLower = "0x".concat(keccak256(Buffer.from(publicKey, "hex")).slice(64 - 38));
      return (0,external_web3_utils_namespaceObject.toChecksumAddress)(ethAddressLower);
    }
  }, {
    key: "generateAddressFromPubKey",
    value: function generateAddressFromPubKey(publicKeyX, publicKeyY) {
      var key = this.ec.keyFromPublic({
        x: publicKeyX.toString("hex", 64),
        y: publicKeyY.toString("hex", 64)
      });
      var publicKey = key.getPublic().encode("hex", false).slice(2);
      loglevel.info(key.getPublic().encode("hex", false), "public key");
      var ethAddressLower = "0x".concat(keccak256(Buffer.from(publicKey, "hex")).slice(64 - 38));
      return (0,external_web3_utils_namespaceObject.toChecksumAddress)(ethAddressLower);
    }
    /**
     * Note: use this function only with custom auth, don't use to lookup openlogin accounts.
     */

  }, {
    key: "getPublicAddress",
    value: function () {
      var _getPublicAddress = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee8(endpoints, torusNodePubs, _ref7) {
        var verifier,
            verifierId,
            isExtended,
            finalKeyResult,
            isNewKey,
            _ref8,
            keyResult,
            errorResult,
            assignResult,
            _nonce,
            _finalKeyResult$keys$2,
            X,
            Y,
            nonceResult,
            nonce,
            modifiedPubKey,
            typeOfUser,
            pubNonce,
            address,
            _args8 = arguments;

        return regenerator_default().wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                verifier = _ref7.verifier, verifierId = _ref7.verifierId;
                isExtended = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : false;
                loglevel.debug("> torus.js/getPublicAddress", {
                  endpoints: endpoints,
                  torusNodePubs: torusNodePubs,
                  verifier: verifier,
                  verifierId: verifierId,
                  isExtended: isExtended
                });
                isNewKey = false;
                _context8.next = 6;
                return keyLookup(endpoints, verifier, verifierId);

              case 6:
                _context8.t0 = _context8.sent;

                if (_context8.t0) {
                  _context8.next = 9;
                  break;
                }

                _context8.t0 = {};

              case 9:
                _ref8 = _context8.t0;
                keyResult = _ref8.keyResult;
                errorResult = _ref8.errorResult;

                if (!(errorResult && JSON.stringify(errorResult).includes("Verifier not supported"))) {
                  _context8.next = 16;
                  break;
                }

                throw new Error("Verifier not supported. Check if you: \n\n      1. Are on the right network (Torus testnet/mainnet) \n\n      2. Have setup a verifier on dashboard.web3auth.io?");

              case 16:
                if (!(errorResult && JSON.stringify(errorResult).includes("Verifier + VerifierID has not yet been assigned"))) {
                  _context8.next = 26;
                  break;
                }

                _context8.next = 19;
                return keyAssign({
                  endpoints: endpoints,
                  torusNodePubs: torusNodePubs,
                  lastPoint: undefined,
                  firstPoint: undefined,
                  verifier: verifier,
                  verifierId: verifierId,
                  signerHost: this.signerHost,
                  network: this.network
                });

              case 19:
                _context8.next = 21;
                return waitKeyLookup(endpoints, verifier, verifierId, 1000);

              case 21:
                assignResult = _context8.sent;
                finalKeyResult = assignResult === null || assignResult === void 0 ? void 0 : assignResult.keyResult;
                isNewKey = true;
                _context8.next = 31;
                break;

              case 26:
                if (!keyResult) {
                  _context8.next = 30;
                  break;
                }

                finalKeyResult = keyResult;
                _context8.next = 31;
                break;

              case 30:
                throw new Error("node results do not match at first lookup ".concat(JSON.stringify(keyResult || {}), ", ").concat(JSON.stringify(errorResult || {})));

              case 31:
                loglevel.debug("> torus.js/getPublicAddress", {
                  finalKeyResult: finalKeyResult,
                  isNewKey: isNewKey
                });

                if (!finalKeyResult) {
                  _context8.next = 69;
                  break;
                }

                _finalKeyResult$keys$2 = finalKeyResult.keys[0], X = _finalKeyResult$keys$2.pub_key_X, Y = _finalKeyResult$keys$2.pub_key_Y;

                if (!this.enableOneKey) {
                  _context8.next = 57;
                  break;
                }

                _context8.prev = 35;
                _context8.next = 38;
                return this.getOrSetNonce(X, Y, undefined, !isNewKey);

              case 38:
                nonceResult = _context8.sent;
                nonce = new (external_bn_js_default())(nonceResult.nonce || "0", 16);
                typeOfUser = nonceResult.typeOfUser;
                _context8.next = 46;
                break;

              case 43:
                _context8.prev = 43;
                _context8.t1 = _context8["catch"](35);
                throw new GetOrSetNonceError();

              case 46:
                if (!(nonceResult.typeOfUser === "v1")) {
                  _context8.next = 50;
                  break;
                }

                modifiedPubKey = this.ec.keyFromPublic({
                  x: X,
                  y: Y
                }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());
                _context8.next = 55;
                break;

              case 50:
                if (!(nonceResult.typeOfUser === "v2")) {
                  _context8.next = 54;
                  break;
                }

                if (nonceResult.upgraded) {
                  // OneKey is upgraded to 2/n, returned address is address of Torus key (postbox key), not tKey
                  modifiedPubKey = this.ec.keyFromPublic({
                    x: X,
                    y: Y
                  }).getPublic();
                } else {
                  modifiedPubKey = this.ec.keyFromPublic({
                    x: X,
                    y: Y
                  }).getPublic().add(this.ec.keyFromPublic({
                    x: nonceResult.pubNonce.x,
                    y: nonceResult.pubNonce.y
                  }).getPublic());
                  pubNonce = nonceResult.pubNonce;
                }

                _context8.next = 55;
                break;

              case 54:
                throw new Error("getOrSetNonce should always return typeOfUser.");

              case 55:
                _context8.next = 62;
                break;

              case 57:
                typeOfUser = "v1";
                _context8.next = 60;
                return this.getMetadata({
                  pub_key_X: X,
                  pub_key_Y: Y
                });

              case 60:
                nonce = _context8.sent;
                modifiedPubKey = this.ec.keyFromPublic({
                  x: X,
                  y: Y
                }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());

              case 62:
                X = modifiedPubKey.getX().toString(16);
                Y = modifiedPubKey.getY().toString(16);
                address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY());
                loglevel.debug("> torus.js/getPublicAddress", {
                  X: X,
                  Y: Y,
                  address: address,
                  typeOfUser: typeOfUser,
                  nonce: (_nonce = nonce) === null || _nonce === void 0 ? void 0 : _nonce.toString(16),
                  pubNonce: pubNonce
                });

                if (isExtended) {
                  _context8.next = 68;
                  break;
                }

                return _context8.abrupt("return", address);

              case 68:
                return _context8.abrupt("return", {
                  typeOfUser: typeOfUser,
                  address: address,
                  X: X,
                  Y: Y,
                  metadataNonce: nonce,
                  pubNonce: pubNonce
                });

              case 69:
                throw new Error("node results do not match at final lookup ".concat(JSON.stringify(keyResult || {}), ", ").concat(JSON.stringify(errorResult || {})));

              case 70:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[35, 43]]);
      }));

      function getPublicAddress(_x15, _x16, _x17) {
        return _getPublicAddress.apply(this, arguments);
      }

      return getPublicAddress;
    }()
    /**
     * Internal functions for OneKey (OpenLogin v2), only call these functions if you know what you're doing
     */

  }, {
    key: "getOrSetNonce",
    value: function () {
      var _getOrSetNonce = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee9(X, Y, privKey) {
        var getOnly,
            data,
            msg,
            _args9 = arguments;
        return regenerator_default().wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                getOnly = _args9.length > 3 && _args9[3] !== undefined ? _args9[3] : false;
                msg = getOnly ? "getNonce" : "getOrSetNonce";

                if (privKey) {
                  data = this.generateMetadataParams(msg, privKey);
                } else {
                  data = {
                    pub_key_X: X,
                    pub_key_Y: Y,
                    set_data: {
                      data: msg
                    }
                  };
                }

                return _context9.abrupt("return", (0,http_helpers_namespaceObject.post)("".concat(this.metadataHost, "/get_or_set_nonce"), data, undefined, {
                  useAPIKey: true
                }));

              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getOrSetNonce(_x18, _x19, _x20) {
        return _getOrSetNonce.apply(this, arguments);
      }

      return getOrSetNonce;
    }()
  }, {
    key: "getNonce",
    value: function () {
      var _getNonce = asyncToGenerator_default()( /*#__PURE__*/regenerator_default().mark(function _callee10(X, Y, privKey) {
        return regenerator_default().wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                return _context10.abrupt("return", this.getOrSetNonce(X, Y, privKey, true));

              case 1:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getNonce(_x21, _x22, _x23) {
        return _getNonce.apply(this, arguments);
      }

      return getNonce;
    }()
  }, {
    key: "getPostboxKeyFrom1OutOf1",
    value: function getPostboxKeyFrom1OutOf1(privKey, nonce) {
      var privKeyBN = new (external_bn_js_default())(privKey, 16);
      var nonceBN = new (external_bn_js_default())(nonce, 16);
      return privKeyBN.sub(nonceBN).umod(this.ec.curve.n).toString("hex");
    }
  }], [{
    key: "enableLogging",
    value: function enableLogging() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (v) loglevel.enableAll();else loglevel.disableAll();
    }
  }, {
    key: "setAPIKey",
    value: function setAPIKey(apiKey) {
      (0,http_helpers_namespaceObject.setAPIKey)(apiKey);
    }
  }, {
    key: "setEmbedHost",
    value: function setEmbedHost(embedHost) {
      (0,http_helpers_namespaceObject.setEmbedHost)(embedHost);
    }
  }, {
    key: "isGetOrSetNonceError",
    value: function isGetOrSetNonceError(err) {
      return err instanceof GetOrSetNonceError;
    }
  }]);

  return Torus;
}();

/* harmony default export */ const torus = (Torus);
;// CONCATENATED MODULE: ./src/index.ts



module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=torusUtils.cjs.js.map